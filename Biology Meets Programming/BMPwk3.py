# Count - creates a dictionary with all the nucleotides and how much they are present in the j-th column of the Motif matrix

def Count(Motifs):
    count = {}
    k = len(Motifs[0])
    for symbol in 'ACGT':
        count[symbol] = []
        for j in range(k):
            count[symbol].append(0)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            count[symbol][j] += 1
    return count

# Profile - frequency of i-th nucleotide in the j-th column of the Motif matrix


def Profile(Motifs):
    profile = {}
    k = len(Motifs[0])
    for symbol in 'ACGT':
        profile[symbol] = []
        for j in range(k):
            profile[symbol].append(0)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            profile[symbol][j] += 1
    for letter, values in profile.items():
        new_vals = [v / t for v in values]
        profile[letter] = new_vals
    return profile

# Consensus - string formed from the most frequent nucleotide per row in Motif matrix
# uses Count matrix


def Consensus(Motifs):
    k = len(Motifs[0])
    count = Count(Motifs)
    consensus = ""
    for j in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count[symbol][j] > m:
                m = count[symbol][j]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus

# Score - summing the number of symbols in the j-th column of Motifs that do not match the symbol in position j of the consensus string
# uses Consensus and Count matrix


def Score(Motifs):
    count = Count(Motifs)
    consensus = Consensus(Motifs)
    letters = {'A', 'C', 'T', 'G'}
    running_sum = 0
    for i, letter in enumerate(consensus):
        losers = letters - set(letter)
        for remaining_letter in losers:
            running_sum += count[remaining_letter][i]
    return running_sum

# Probability - of finding a chosen kmer given the profile matrix
# Profile = {"A":[0.1,0.2],"T":[0.5,0.2]} etc


def Pr(Text, Profile):
    pro = 1
    for i in range(len(Text)):
        pro = pro*Profile[Text[i]][i]
    return pro


# Profile most probable kmer - a kmer that was most likely to have been generated by Profile among all kmers in Text
# Uses Pr function


def ProfileMostProbableKmer(text, k, profile):
    n = len(text)
    m = 0
    x = text[1:k]
    for i in range(n-k+1):
        Pattern = text[i:i+k]
        p = Pr(Pattern, profile)
        if p > m:
            m = p
            x = Pattern
    return x
