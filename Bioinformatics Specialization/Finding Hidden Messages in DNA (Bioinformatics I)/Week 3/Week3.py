# Motif Enumeration - Returns all (k,d)-motifs in Dna.  A kmer is a k,d motif if it appears in every string
# from Dna with at most d mismatches
# uses updateneighbours,suffix,firstsymbol,hammingdistance
""" 
k = 3 
d = 1 
Dna = ["ATTTGGC","TGCCTTA","CGGTATC","GAAAATT"]
"""


import math


def Suffix(Pattern):
    if len(Pattern) == 1:
        return ""
    suffix = Pattern[1:]
    return suffix


def FirstSymbol(Pattern):
    x = Pattern[0]
    return x


def UpdateNeighbours(Pattern, d):
    if d == 0:
        return {Pattern}
    if len(Pattern) == 1:
        x = ['A', 'C', 'T', 'G']
        return x
    Neighbourhood = set()
    SuffixNeighbours = UpdateNeighbours(Suffix(Pattern), d)
    for Text in SuffixNeighbours:
        if HammingDistance(Suffix(Pattern), Text) < d:
            for y in "ATCG":
                string = y + Text
                Neighbourhood.add(string)
        else:
            m = FirstSymbol(Pattern) + Text
            Neighbourhood.add(m)
    Neighbourhood = list(Neighbourhood)
    return Neighbourhood


def MotifEnumeration(Dna, k, d):
    patterns = set()
    n = len(Dna)
    AllKmers = []
    for j in range(n):
        a = Dna[j]
        kmers = []
        n_1 = len(a)
        for i in range(n_1 - k + 1):
            kmers.append(a[i:i+k])
        neigh = []
        for i in range(len(kmers)):
            l = UpdateNeighbours(kmers[i], d)
            for val in l:
                neigh.append(val)
        AllKmers.append(neigh)
    x1 = set(AllKmers[0])
    x2 = set(AllKmers[1])
    patterns = x1 and x2
    for y in range(2, len(AllKmers)):
        patterns = patterns and set(AllKmers[y])
    patterns = list(patterns)
    string = ""
    for i in patterns:
        string = string + i + " "
    return string

# Entropy - Measure of the uncertainty of a probability distribution, calculated from the profile matrix.


H = 0
for i in range(len(Motifs[1])):
    A = 0
    T = 0
    C = 0
    G = 0
    for j in range(len(Motifs)):
        if Motifs[j][i] == 'A':
            A += 1/len(Motifs)
        if Motifs[j][i] == 'T':
            T += 1/len(Motifs)
        if Motifs[j][i] == 'C':
            C += 1/len(Motifs)
        if Motifs[j][i] == 'G':
            G += 1/len(Motifs)
    m = [A, T, C, G]
    for i in range(4):
        if m[i] != 0:
            H += m[i]*math.log2(m[i])

print('Entropy=', abs(H))


# Median String - a fast algorithm for generating Motifs(Pattern,Dna), a collection of Motifs(Pattern,Dna) as a collection
# of kmers that minimize d(Pattern,Motifs) where d is the hamming distance
# uses  neighbors, hammingdistance

""" 
Dna = ['TTACCTTAAC', 
        'GATATCTGTC', 
        'ACGGCGTTCG', 
        'CCCTAAAGAG', 
        'CGTCAGAGGT']

k = 7
"""


def MedianString(Dna, k):

    def get_distance(Pattern, Text):
        n = len(Text)
        k = len(Pattern)
        min_distance = HammingDistance(Text[:k], Pattern)
        for i in range(n - k + 1):
            distance = HammingDistance(Text[i:i + k], Pattern)
            if distance < min_distance:
                min_distance = distance
        return min_distance

    def get_total_distance(Pattern, Dna):
        total_distance = 0
        for text in Dna:
            distance = get_distance(Pattern, text)
            total_distance += distance
        return total_distance

    kmers = Neighbors("A" * k, k)

    min_pattern = kmers[0]
    min_total_distance = get_total_distance(min_pattern, Dna)
    for pattern in kmers[1:]:
        total_distance = get_total_distance(pattern, Dna)
        if total_distance < min_total_distance:
            min_pattern = pattern
            min_total_distance = total_distance

    return min_pattern


print(ConvertToWords(MedianString(Dna, k)))

# Profile most probable Kmer - k-mer that was most likely to have been generated by Profile among all k-mers in Text
# Uses Pr - probability of finding a chosen kmer in the profile matrix

""" 
Text = "ACCTGTTTATTGCCTAAGTTCCGAACAAACCCAATATAGCCCGAGGGCCT"
k = 5
matrix  = 
0.2 0.2 0.3 0.2 0.3
0.4 0.3 0.1 0.5 0.1
0.3 0.3 0.5 0.2 0.4
0.1 0.2 0.1 0.1 0.2

# Read the text file:
with open('filename.txt', 'r') as file:
	Text = file.readline().strip() # moves throughout the rows
	k = int(file.readline().strip())
	Profile = {}
	Profile['A'] = file.readline().strip().split(' ')
	Profile['C'] = file.readline().strip().split(' ')
	Profile['G'] = file.readline().strip().split(' ')
	Profile['T'] = file.readline().strip().split(' ')
"""


def Pr(Text, Profile):
    p = 1
    for i in range(len(Text)):
        p *= Profile[Text][i][i]
    return p


def ProfileMostProbableKmer(Text, k, Profile):
    n = len(Text)
    m = 0
    x = Text[1:k]
    for i in range(n-k+1):
        Pattern = Text[i:i+k]
        p = Pr(Pattern, Profile)
        if p > m:
            m = p
            x = Pattern
    return x


# Greedy motif search - Output: A collection of strings BestMotifs resulting from applying
# GreedyMotifSearch(Dna, k, t). If at any step you find more than one Profile-most probable k-mer
# in a given string, use the one occurring first.
# uses score,profile,profilemostprobablekmer (updated)
""" 
k = 3
t = 5
Dna = [
"GGCGTTCAGGCA",
"AAGAATCAGTCA",
"CAAGGAGTTCGC",
"CACGTCAATCAC",
"CAATAATATTCG",
]
"""


def GreedyMotifSearch(Dna, k, t):
    bestmotifs = [string[:k]for string in Dna]
    for j in range(len(Dna[0])-k+1):
        motifs = [Dna[0][j:j+k]]
        for i in range(1, t):
            motifs += [profilemostprobablekmer(Dna[i], k, profile(motifs))]
        if score(motifs) < score(bestmotifs):
            bestmotifs = motifs
    return bestmotifs


def profile(motifs):
    transposed = [list(row) for row in zip(*motifs)]
    n = len(motifs)
    profile = {nucleotide: [i.count(nucleotide)/n for i in transposed] for nucleotide in 'ACGT'}
    return profile


def score(motifs):
    transposed = [list(row) for row in zip(*motifs)]
    counted = [[i.count(nucleotide) for nucleotide in 'ACGT'] for i in transposed]
    scored = sum([len(motifs)-max(i) for i in counted])
    return scored


def profilemostprobablekmer(text, k, profile):
    probability = []
    for i in range(len(text)-k+1):
        compute = 1
        for j in range(k):
            compute = compute*(profile[text[i+j]][j])
        probability.append(compute)
    idx = probability.index(max(probability))
    return text[idx:idx+k]


print((*GreedyMotifSearch(Dna, k, t)))  # Astericks converts list to string

# Greedy Motif Search with PSEUDOCOUNTS - Output: A collection of strings BestMotifs
# resulting from applying GreedyMotifSearch(Dna, k, t) with pseudocounts.
# If at any step you find more than one Profile-most probable k-mer in a given string,
# use the one occurring first.
# uses score,consensus,count,Pr,ProfileMostProbableKmer, ProfileWithPseudocounts, CountWithPseudocounts,Pr,Profilemostprobablekmer
""" 
Dna = ["GGCGTTCAGGCA",
"AAGAATCAGTCA",
"CAAGGAGTTCGC",
"CACGTCAATCAC",
"CAATAATATTCG"
]
k = 3 
t = 5
"""
Dna = []

with open("C:/Users/18687/Desktop/Bio Informatics/newdata.txt", 'r') as file:
    k = int(file.readline().strip())  # moves throughout the rows
    t = int(file.readline().strip())
    for item in file.readlines():
        Dna.append(item.strip())

file.close()


def GreedyMotifSearchWithPseudocounts(Dna, k, t):
    BestMotifs = []
    for i in range(t):
        BestMotifs.append(Dna[i][:k])
    n = len(Dna[0])
    for _ in range(n-k+1):
        Motifs = []
        Motifs.append(Dna[0][i:i+k])
        for j in range(1, t):
            P = ProfileWithPseudocounts(Motifs[0:j])
            Motifs.append(ProfileMostProbableKmer(Dna[j], k, P))
        if Score(Motifs) < Score(BestMotifs):
            BestMotifs = Motifs
    result = ""
    for item in BestMotifs:
        result = result + "\n" + str(item)
    return result


def CountWithPseudocounts(Motifs):
    count = {}
    k = len(Motifs[0])
    for symbol in "ACGT":
        count[symbol] = []
        for j in range(k):
            count[symbol].append(1)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            count[symbol][j] += 1
    return count

# Profile with Pseudocounts - takes a list of strings Motifs as input and returns the profile matrix of Motifs with pseudocount as a dict
# of lists


def ProfileWithPseudocounts(Motifs):
    k = len(Motifs[0])
    profile = {}
    count = CountWithPseudocounts(Motifs)
    total = 0
    for symbol in "ACGT":
        total += count[symbol][0]
        for k, v in count.items():
            profile[k] = [x/total for x in v]
    return profile


# Count - creates a dictionary with all the nucleotides and how much they are present in the j-th column of the Motif matrix


def Count(Motifs):
    count = {}
    k = len(Motifs[0])
    for symbol in 'ACGT':
        count[symbol] = []
        for j in range(k):
            count[symbol].append(0)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            count[symbol][j] += 1
    return count

# Profile - frequency of i-th nucleotide in the j-th column of the Motif matrix


def Profile(Motifs):
    profile = {}
    k = len(Motifs[0])
    for symbol in 'ACGT':
        profile[symbol] = []
        for j in range(k):
            profile[symbol].append(0)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            profile[symbol][j] += 1
    for letter, values in profile.items():
        new_vals = [v / t for v in values]
        profile[letter] = new_vals
    return profile

# Consensus - string formed from the most frequent nucleotide per row in Motif matrix
# uses Count matrix


def Consensus(Motifs):
    k = len(Motifs[0])
    count = Count(Motifs)
    consensus = ""
    for j in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count[symbol][j] > m:
                m = count[symbol][j]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus

# Score - summing the number of symbols in the j-th column of Motifs that do not match the symbol in position j of the consensus string
# uses Consensus and Count matrix


def Score(Motifs):
    count = Count(Motifs)
    consensus = Consensus(Motifs)
    letters = {'A', 'C', 'T', 'G'}
    running_sum = 0
    for i, letter in enumerate(consensus):
        losers = letters - set(letter)
        for remaining_letter in losers:
            running_sum += count[remaining_letter][i]
    return running_sum


x = GreedyMotifSearchWithPseudocounts(Dna, k, t)
print("".join(x))


# Distance between pattern and strings -  the sum of distances between Pattern and each string in Dna = {Dna1, ..., Dnat}
# returns the distance between Pattern and Dna
# uses HammingDistance
""" 
Pattern = "AAA"
Dna = "TTACCTTAAC GATATCTGTC ACGGCGTTCG CCCTAAAGAG CGTCAGAGGT"
"""

Dna = list(map(str, Dna.split()))


def DistanceBetweenPatternAndString(Pattern, Dna):
    k = len(Pattern)
    d = 0
    for text in Dna:
        d_temp = float('Inf')
        for i in range(len(text) - k + 1):
            if d_temp > HammingDistance(Pattern, text[i:i+k]):
                d_temp = HammingDistance(Pattern, text[i:i+k])
        d += d_temp
    return d


def HammingDistance(p, q):
    count = 0
    for x, y in zip(p, q):
        if x != y:
            count += 1
    return count


print(DistanceBetweenPatternAndString(Pattern, Dna))
