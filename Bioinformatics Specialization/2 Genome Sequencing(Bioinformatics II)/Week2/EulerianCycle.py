# Eulerian Cycle Problem - walks depth first in the graph to find the cycle returning a euler cycle
# Returns the cycle generated by moving through the adjacency list of a
# directed graph that is Eulerian (balanced and strongly connected)

with open('C:/Users/18687/Desktop/Bio Informatics/Bioinformatics specialization/euleriancycle.txt', 'r') as file:
    graph = dict((line.strip().split(' -> ') for line in file))
    for key in graph:
        graph[key] = graph[key].split(',')


def EulerianCycle(graph):
    cycle = []
    stack = []
    new_start = list(graph.keys())[0]
    stack.append(new_start)
    while len(stack) != 0:  # while the graph is not empty
        start = stack[-1]  # the start node is the top of the stack
        if graph.get(start):  # if it exists in the graph
            end = graph[start][0]  # the end node is found with adjacency list
            stack.append(end)  # add it to the top of the stack
            graph[start].remove(end)  # remove it from the graph
        else:  # if the start node is not in the graph
            # add the start node to the cycle AND remove it from the stack
            cycle.append(stack.pop())

    num_edges = sum((len(v) for v in graph.values()))
    if num_edges == 0:  # check to see if all edges were visited
        return list(reversed(cycle))  # the cycle is in the reverse order
    return []


#path = EulerianCycle(graph)
#print(" -> ".join(map(str, path)))

with open('C:/Users/18687/Desktop/Bio Informatics/Bioinformatics specialization/euleriancycleanswer.txt', 'w') as output_data:
    output_data.write('->'.join(EulerianCycle(graph)))

if __name__ == "__main__":
    EulerianCycle(graph)
