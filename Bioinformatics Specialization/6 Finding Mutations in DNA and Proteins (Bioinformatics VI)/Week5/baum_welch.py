'''
CODE CHALLENGE: Implement Baum-Welch Learning.
Input: A sequence of emitted symbols x = x1 . . . xn in an alphabet A, generated by a k-state HMM with
 unknown transition and emission probabilities, initial Transition and Emission matrices and a number of iterations I.
Output: A matrix of transition probabilities Transition and a matrix of emission probabilities Emission that
 maximizes Pr(x,π) over all possible transition and emission matrices and over all hidden paths π.
'''
from soft_decoding import forward_probability, backward_probability
import numpy as np
import pandas as pd


def HMM_Soft_Decoding_hidden(string, alphabet, states, transition_matrix, state_emission_matrix):

    forward_prob_matrix = forward_probability(
        string, alphabet, states, transition_matrix, state_emission_matrix)
    backward_prob_matrix = backward_probability(
        string, alphabet, states, transition_matrix, state_emission_matrix)

    prob_forwad_sink = sum(forward_prob_matrix[:, -1])

    node_prob_matrix = np.full([len(states), len(string)], 0, float)
    for i in range(len(string)):

        for k_index in range(len(states)):
            forward_probability_k_i = forward_prob_matrix[k_index, i]
            backward_probability_k_i = backward_prob_matrix[k_index, i]

            node_prob_matrix[k_index, i] = forward_probability_k_i * \
                backward_probability_k_i / prob_forwad_sink

    edge_prob_matrix = np.full([len(states), len(states), len(string)], 0, float)
    for k1 in range(len(states)):
        for k2 in range(len(states)):
            for i in range(len(string) - 1):
                edge_prob_matrix[k1, k2, i] = forward_prob_matrix[k1, i] * transition_matrix.at[states[k1], states[k2]] * \
                    state_emission_matrix.at[states[k2], string[i + 1]] * \
                    backward_prob_matrix[k2, i + 1] / prob_forwad_sink

    return(node_prob_matrix, edge_prob_matrix)


def Estimate_Parameters_Matrix(string, alphabet, states, node_prob_matrix, edge_prob_matrix):
    transition_matrix = np.full([len(states), len(states)], 0, float)
    transition_matrix = pd.DataFrame(transition_matrix, index=states, columns=states)

    state_emission_matrix = np.full([len(states), len(alphabet)], 0, float)
    state_emission_matrix = pd.DataFrame(state_emission_matrix, index=states, columns=alphabet)

    for state_i_1 in range(len(states)):
        state_1 = states[state_i_1]
        for state_i_2 in range(len(states)):
            state_2 = states[state_i_2]
            transition_matrix.at[state_1, state_2] = sum(edge_prob_matrix[state_i_1, state_i_2, :])

    for state_i in range(len(states)):
        state = states[state_i]
        for emission_i in range(len(string)):
            emission = string[emission_i]
            state_emission_matrix.at[state, emission] = state_emission_matrix.at[state,
                                                                                 emission] + node_prob_matrix[state_i, emission_i]

    for i in range(len(states)):
        if sum(transition_matrix.iloc[i]) == 0:
            transition_matrix.iloc[i] = transition_matrix.iloc[i] + 1
        if sum(state_emission_matrix.iloc[i]) == 0:
            state_emission_matrix.iloc[i] = state_emission_matrix.iloc[i] + 1

        transition_matrix.iloc[i] = transition_matrix.iloc[i] / sum(transition_matrix.iloc[i])
        state_emission_matrix.iloc[i] = state_emission_matrix.iloc[i] / \
            sum(state_emission_matrix.iloc[i])

    return(transition_matrix, state_emission_matrix)


def Baum_Welch_Learning(iterations, string, alphabet, states, initial_transition_matrix, initial_state_emission_matrix):
    alphabet = alphabet.split(' ')
    states = states.split(' ')

    initial_transition_matrix = initial_transition_matrix.split('\n')
    for i in range(len(initial_transition_matrix)):
        initial_transition_matrix[i] = initial_transition_matrix[i].split('\t')
        initial_transition_matrix[i] = list(map(float, initial_transition_matrix[i]))
    initial_transition_matrix = pd.DataFrame(
        initial_transition_matrix, columns=states, index=states)

    initial_state_emission_matrix = initial_state_emission_matrix.split('\n')
    for i in range(len(initial_state_emission_matrix)):
        initial_state_emission_matrix[i] = initial_state_emission_matrix[i].split('\t')
        initial_state_emission_matrix[i] = list(map(float, initial_state_emission_matrix[i]))
    initial_state_emission_matrix = pd.DataFrame(
        initial_state_emission_matrix, columns=alphabet, index=states)

    transition_matrix, state_emission_matrix = initial_transition_matrix, initial_state_emission_matrix

    for i in range(iterations):
        node_prob_matrix, edge_prob_matrix = HMM_Soft_Decoding_hidden(
            string, alphabet, states, transition_matrix, state_emission_matrix)
        transition_matrix, state_emission_matrix = Estimate_Parameters_Matrix(
            string, alphabet, states, node_prob_matrix, edge_prob_matrix)

    return(transition_matrix, state_emission_matrix)


iterations = 10
string = 'xzyyzyzyxy'
alphabet = 'x y z'
states = 'A B'
initial_transition_matrix = '''0.019	0.981
0.668	0.332'''
initial_state_emission_matrix = '''0.175	0.003	0.821
0.196	0.512	0.293'''

transition_matrix, state_emission_matrix = Baum_Welch_Learning(
    iterations, string, alphabet, states, initial_transition_matrix, initial_state_emission_matrix)
print(transition_matrix.to_string())
print(state_emission_matrix.to_string())
